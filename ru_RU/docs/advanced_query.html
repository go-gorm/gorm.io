<!DOCTYPE html>
<html lang="ru_RU">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <title>Расширенный запрос | GORM - The fantastic ORM library for Golang, aims to be developer friendly.</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="https://gorm.io/ru_RU/docs/advanced_query.html">
  <!-- Alternative links -->
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <!-- CSS -->
  <!-- build:css build/css/navy.css -->
  
<link rel="stylesheet" href="/css/navy.css">

  <!-- endbuild -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
  <!-- RSS -->
  <link rel="alternate" href="/atom.xml" title="GORM" type="application/atom+xml">
  <!-- Open Graph -->
  <meta name="description" content="Умный выбор полейIn GORM, you can efficiently select specific fields using the Select method. This is particularly useful when dealing with large models but requiring only a subset of fields, especial">
<meta property="og:type" content="website">
<meta property="og:title" content="Расширенный запрос">
<meta property="og:url" content="https://gorm.io/ru_RU/docs/advanced_query.html">
<meta property="og:site_name" content="GORM">
<meta property="og:description" content="Умный выбор полейIn GORM, you can efficiently select specific fields using the Select method. This is particularly useful when dealing with large models but requiring only a subset of fields, especial">
<meta property="og:locale" content="ru_RU">
<meta property="article:published_time" content="2024-06-12T08:58:10.034Z">
<meta property="article:modified_time" content="2024-06-12T08:58:10.034Z">
<meta property="article:author" content="Jinzhu">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="zhangjinzhu">
  <!-- Google Tag Manager -->
  <meta name="google-adsense-account" content="ca-pub-1190038979533623">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-WSNPD75');</script>


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="/ru_RU/" id="logo">
        <img src="/gorm.svg" alt="GORM">
      </a>
    </h1>
    <nav id="main-nav">
      <a href="/ru_RU/docs/" class="main-nav-link"><i class="fa fa-book"></i>Документация</a><a href="/ru_RU/gen/" class="main-nav-link"><i class="fa fa-tools"></i>Gen</a><a href="/ru_RU/community.html" class="main-nav-link"><i class="fab fa-slack"></i>Сообщество</a><a href="https://pkg.go.dev/gorm.io/gorm" class="main-nav-link" target="_blank"><i class="fa fa-cogs"></i>API</a><a href="/ru_RU/contribute.html" class="main-nav-link"><i class="fa fa-rocket"></i>Внести вклад</a>
      <div id="search-input-wrap">
        <div id="search-input-icon">
          <i class="fa fa-search"></i>
        </div>
        <input type="search" id="search-input" placeholder="Поиск в документации...">
      </div>
    </nav>
    <div id="lang-select-wrap">
      <label id="lang-select-label"><i class="fa fa-globe"></i><span>Русский</span></label>
      <select id="lang-select" data-canonical="docs/advanced_query.html">
        
          <option value="en">English</option>
        
          <option value="zh_CN">简体中文</option>
        
          <option value="de_DE">Deutsch</option>
        
          <option value="id_ID">bahasa Indonesia</option>
        
          <option value="ja_JP">日本語</option>
        
          <option value="ru_RU" selected>Русский</option>
        
          <option value="ko_KR">한국어</option>
        
          <option value="hi_IN">हिन्दी</option>
        
          <option value="fr_FR">French</option>
        
          <option value="it_IT">Italiano</option>
        
          <option value="es_ES">Español</option>
        
      </select>
    </div>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope itemtype="http://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name">Расширенный запрос</h1>
                
                <a target="_blank" rel="noopener" href="https://translate.gorm.io/project/go-gorm/ru" class="article-edit-link" title="Улучшить эту страницу"><i class="fa fa-pencil"></i></a>
                
              </header>
              <div class="article-content" itemprop="articleBody">
                <html><head></head><body><h2 id="Умный-выбор-полей" class="article-heading"><a href="#Умный-выбор-полей" class="headerlink" title="Умный выбор полей"></a><span id="smart_select">Умный выбор полей</span><a class="article-anchor" href="#Умный-выбор-полей" aria-hidden="true"></a></h2><p>In GORM, you can efficiently select specific fields using the <a href="query.html"><code>Select</code></a> method. This is particularly useful when dealing with large models but requiring only a subset of fields, especially in API responses.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> {</span><br><span class="line">  ID     <span class="type">uint</span></span><br><span class="line">  Name   <span class="type">string</span></span><br><span class="line">  Age    <span class="type">int</span></span><br><span class="line">  Gender <span class="type">string</span></span><br><span class="line">  <span class="comment">// hundreds of fields</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> APIUser <span class="keyword">struct</span> {</span><br><span class="line">  ID   <span class="type">uint</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// GORM will automatically select `id`, `name` fields when querying</span></span><br><span class="line">db.Model(&amp;User{}).Limit(<span class="number">10</span>).Find(&amp;APIUser{})</span><br><span class="line"><span class="comment">// SQL: SELECT `id`, `name` FROM `users` LIMIT 10</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote class="note warn"><p><strong>NOTE</strong> In <code>QueryFields</code> mode, all model fields are selected by their names.</p>
</blockquote>

<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db, err := gorm.Open(sqlite.Open(<span class="string">"gorm.db"</span>), &amp;gorm.Config{</span><br><span class="line">  QueryFields: <span class="literal">true</span>,</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default behavior with QueryFields set to true</span></span><br><span class="line">db.Find(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT `users`.`name`, `users`.`age`, ... FROM `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Using Session Mode with QueryFields</span></span><br><span class="line">db.Session(&amp;gorm.Session{QueryFields: <span class="literal">true</span>}).Find(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT `users`.`name`, `users`.`age`, ... FROM `users`</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Locking" class="article-heading"><a href="#Locking" class="headerlink" title="Locking"></a>Locking<a class="article-anchor" href="#Locking" aria-hidden="true"></a></h2><p>GORM поддерживает различные типы блокировок, например:</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Basic FOR UPDATE lock</span></span><br><span class="line">db.Clauses(clause.Locking{Strength: <span class="string">"UPDATE"</span>}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `users` FOR UPDATE</span></span><br></pre></td></tr></tbody></table></figure>

<p>The above statement will lock the selected rows for the duration of the transaction. This can be used in scenarios where you are preparing to update the rows and want to prevent other transactions from modifying them until your transaction is complete.</p>
<p>The <code>Strength</code> can be also set to <code>SHARE</code> which locks the rows in a way that allows other transactions to read the locked rows but not to update or delete them.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Clauses(clause.Locking{</span><br><span class="line">  Strength: <span class="string">"SHARE"</span>,</span><br><span class="line">  Table: clause.Table{Name: clause.CurrentTable},</span><br><span class="line">}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `users` FOR SHARE OF `users`</span></span><br></pre></td></tr></tbody></table></figure>

<p>The <code>Table</code> option can be used to specify the table to lock. This is useful when you are joining multiple tables and want to lock only one of them.</p>
<p>Options can be provided like <code>NOWAIT</code> which  tries to acquire a lock and fails immediately with an error if the lock is not available. It prevents the transaction from waiting for other transactions to release their locks.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">db.Clauses(clause.Locking{</span><br><span class="line">  Strength: <span class="string">"UPDATE"</span>,</span><br><span class="line">  Options: <span class="string">"NOWAIT"</span>,</span><br><span class="line">}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `users` FOR UPDATE NOWAIT</span></span><br></pre></td></tr></tbody></table></figure>

<p>Another option can be <code>SKIP LOCKED</code> which skips over any rows that are already locked by other transactions. This is useful in high concurrency situations where you want to process rows that are not currently locked by other transactions.</p>
<p>For more advanced locking strategies, refer to <a href="sql_builder.html">Raw SQL and SQL Builder</a>.</p>
<h2 id="Подзапрос" class="article-heading"><a href="#Подзапрос" class="headerlink" title="Подзапрос"></a>Подзапрос<a class="article-anchor" href="#Подзапрос" aria-hidden="true"></a></h2><p>Subqueries are a powerful feature in SQL, allowing nested queries. GORM can generate subqueries automatically when using a *gorm.DB object as a parameter.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Simple subquery</span></span><br><span class="line">db.Where(<span class="string">"amount &gt; (?)"</span>, db.Table(<span class="string">"orders"</span>).Select(<span class="string">"AVG(amount)"</span>)).Find(&amp;orders)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM "orders" WHERE amount &gt; (SELECT AVG(amount) FROM "orders");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Nested subquery</span></span><br><span class="line">subQuery := db.Select(<span class="string">"AVG(age)"</span>).Where(<span class="string">"name LIKE ?"</span>, <span class="string">"name%"</span>).Table(<span class="string">"users"</span>)</span><br><span class="line">db.Select(<span class="string">"AVG(age) as avgage"</span>).Group(<span class="string">"name"</span>).Having(<span class="string">"AVG(age) &gt; (?)"</span>, subQuery).Find(&amp;results)</span><br><span class="line"><span class="comment">// SQL: SELECT AVG(age) as avgage FROM `users` GROUP BY `name` HAVING AVG(age) &gt; (SELECT AVG(age) FROM `users` WHERE name LIKE "name%")</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Из-SubQuery-под-запроса" class="article-heading"><a href="#Из-SubQuery-под-запроса" class="headerlink" title="Из SubQuery (под запроса)"></a><span id="from_subquery">Из SubQuery (под запроса)</span><a class="article-anchor" href="#Из-SubQuery-под-запроса" aria-hidden="true"></a></h3><p>GORM allows the use of subqueries in the FROM clause, enabling complex queries and data organization.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Using subquery in FROM clause</span></span><br><span class="line">db.Table(<span class="string">"(?) as u"</span>, db.Model(&amp;User{}).Select(<span class="string">"name"</span>, <span class="string">"age"</span>)).Where(<span class="string">"age = ?"</span>, <span class="number">18</span>).Find(&amp;User{})</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM (SELECT `name`,`age` FROM `users`) as u WHERE `age` = 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Combining multiple subqueries in FROM clause</span></span><br><span class="line">subQuery1 := db.Model(&amp;User{}).Select(<span class="string">"name"</span>)</span><br><span class="line">subQuery2 := db.Model(&amp;Pet{}).Select(<span class="string">"name"</span>)</span><br><span class="line">db.Table(<span class="string">"(?) as u, (?) as p"</span>, subQuery1, subQuery2).Find(&amp;User{})</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM (SELECT `name` FROM `users`) as u, (SELECT `name` FROM `pets`) as p</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Группировка-условий" class="article-heading"><a href="#Группировка-условий" class="headerlink" title="Группировка условий"></a><span id="group_conditions">Группировка условий</span><a class="article-anchor" href="#Группировка-условий" aria-hidden="true"></a></h2><p>Group Conditions in GORM provide a more readable and maintainable way to write complex SQL queries involving multiple conditions.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Complex SQL query using Group Conditions</span></span><br><span class="line">db.Where(</span><br><span class="line">  db.Where(<span class="string">"pizza = ?"</span>, <span class="string">"pepperoni"</span>).Where(db.Where(<span class="string">"size = ?"</span>, <span class="string">"small"</span>).Or(<span class="string">"size = ?"</span>, <span class="string">"medium"</span>)),</span><br><span class="line">).Or(</span><br><span class="line">  db.Where(<span class="string">"pizza = ?"</span>, <span class="string">"hawaiian"</span>).Where(<span class="string">"size = ?"</span>, <span class="string">"xlarge"</span>),</span><br><span class="line">).Find(&amp;Pizza{})</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `pizzas` WHERE (pizza = "pepperoni" AND (size = "small" OR size = "medium")) OR (pizza = "hawaiian" AND size = "xlarge")</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="IN-с-несколькими-столбцами" class="article-heading"><a href="#IN-с-несколькими-столбцами" class="headerlink" title="IN с несколькими столбцами"></a>IN с несколькими столбцами<a class="article-anchor" href="#IN-с-несколькими-столбцами" aria-hidden="true"></a></h2><p>GORM supports the IN clause with multiple columns, allowing you to filter data based on multiple field values in a single query.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Using IN with multiple columns</span></span><br><span class="line">db.Where(<span class="string">"(name, age, role) IN ?"</span>, [][]<span class="keyword">interface</span>{}{{<span class="string">"jinzhu"</span>, <span class="number">18</span>, <span class="string">"admin"</span>}, {<span class="string">"jinzhu2"</span>, <span class="number">19</span>, <span class="string">"user"</span>}}).Find(&amp;users)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM users WHERE (name, age, role) IN (("jinzhu", 18, "admin"), ("jinzhu 2", 19, "user"));</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Именованные-аргументы" class="article-heading"><a href="#Именованные-аргументы" class="headerlink" title="Именованные аргументы"></a>Именованные аргументы<a class="article-anchor" href="#Именованные-аргументы" aria-hidden="true"></a></h2><p>GORM enhances the readability and maintainability of SQL queries by supporting named arguments. This feature allows for clearer and more organized query construction, especially in complex queries with multiple parameters. Named arguments can be utilized using either <a target="_blank" rel="noopener" href="https://tip.golang.org/pkg/database/sql/#NamedArg"><code>sql.NamedArg</code></a> or <code>map[string]interface{}{}</code>, providing flexibility in how you structure your queries.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Example using sql.NamedArg for named arguments</span></span><br><span class="line">db.Where(<span class="string">"name1 = @name OR name2 = @name"</span>, sql.Named(<span class="string">"name"</span>, <span class="string">"jinzhu"</span>)).Find(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `users` WHERE name1 = "jinzhu" OR name2 = "jinzhu"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example using a map for named arguments</span></span><br><span class="line">db.Where(<span class="string">"name1 = @name OR name2 = @name"</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"name"</span>: <span class="string">"jinzhu"</span>}).First(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `users` WHERE name1 = "jinzhu" OR name2 = "jinzhu" ORDER BY `users`.`id` LIMIT 1</span></span><br></pre></td></tr></tbody></table></figure>

<p>For more examples and details, see <a href="sql_builder.html#named_argument">Raw SQL and SQL Builder</a></p>
<h2 id="Find-с-картами" class="article-heading"><a href="#Find-с-картами" class="headerlink" title="Find с картами"></a>Find с картами<a class="article-anchor" href="#Find-с-картами" aria-hidden="true"></a></h2><p>GORM provides flexibility in querying data by allowing results to be scanned into a <code>map[string]interface{}</code> or <code>[]map[string]interface{}</code>, which can be useful for dynamic data structures.</p>
<p>When using <code>Find To Map</code>, it’s crucial to include <code>Model</code> or <code>Table</code> in your query to explicitly specify the table name. This ensures that GORM understands which table to query against.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Scanning the first result into a map with Model</span></span><br><span class="line">result := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{}</span><br><span class="line">db.Model(&amp;User{}).First(&amp;result, <span class="string">"id = ?"</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `users` WHERE id = 1 LIMIT 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Scanning multiple results into a slice of maps with Table</span></span><br><span class="line"><span class="keyword">var</span> results []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}</span><br><span class="line">db.Table(<span class="string">"users"</span>).Find(&amp;results)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `users`</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="FirstOrInit" class="article-heading"><a href="#FirstOrInit" class="headerlink" title="FirstOrInit"></a>FirstOrInit<a class="article-anchor" href="#FirstOrInit" aria-hidden="true"></a></h2><p>GORM’s <code>FirstOrInit</code> method is utilized to fetch the first record that matches given conditions, or initialize a new instance if no matching record is found. This method is compatible with both struct and map conditions and allows additional flexibility with the <code>Attrs</code> and <code>Assign</code> methods.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// If no User with the name "non_existing" is found, initialize a new User</span></span><br><span class="line"><span class="keyword">var</span> user User</span><br><span class="line">db.FirstOrInit(&amp;user, User{Name: <span class="string">"non_existing"</span>})</span><br><span class="line"><span class="comment">// user -&gt; User{Name: "non_existing"} if not found</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieving a user named "jinzhu"</span></span><br><span class="line">db.Where(User{Name: <span class="string">"jinzhu"</span>}).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// user -&gt; User{ID: 111, Name: "Jinzhu", Age: 18} if found</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Using a map to specify the search condition</span></span><br><span class="line">db.FirstOrInit(&amp;user, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>{}{<span class="string">"name"</span>: <span class="string">"jinzhu"</span>})</span><br><span class="line"><span class="comment">// user -&gt; User{ID: 111, Name: "Jinzhu", Age: 18} if found</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Using-Attrs-for-Initialization" class="article-heading"><a href="#Using-Attrs-for-Initialization" class="headerlink" title="Using Attrs for Initialization"></a>Using <code>Attrs</code> for Initialization<a class="article-anchor" href="#Using-Attrs-for-Initialization" aria-hidden="true"></a></h3><p>When no record is found, you can use <code>Attrs</code> to initialize a struct with additional attributes. These attributes are included in the new struct but are not used in the SQL query.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// If no User is found, initialize with given conditions and additional attributes</span></span><br><span class="line">db.Where(User{Name: <span class="string">"non_existing"</span>}).Attrs(User{Age: <span class="number">20</span>}).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM USERS WHERE name = 'non_existing' ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User{Name: "non_existing", Age: 20} if not found</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If a User named "Jinzhu" is found, `Attrs` are ignored</span></span><br><span class="line">db.Where(User{Name: <span class="string">"Jinzhu"</span>}).Attrs(User{Age: <span class="number">20</span>}).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM USERS WHERE name = 'Jinzhu' ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User{ID: 111, Name: "Jinzhu", Age: 18} if found</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Using-Assign-for-Attributes" class="article-heading"><a href="#Using-Assign-for-Attributes" class="headerlink" title="Using Assign for Attributes"></a>Using <code>Assign</code> for Attributes<a class="article-anchor" href="#Using-Assign-for-Attributes" aria-hidden="true"></a></h3><p>The <code>Assign</code> method allows you to set attributes on the struct regardless of whether the record is found or not. These attributes are set on the struct but are not used to build the SQL query and the final data won’t be saved into the database.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize with given conditions and Assign attributes, regardless of record existence</span></span><br><span class="line">db.Where(User{Name: <span class="string">"non_existing"</span>}).Assign(User{Age: <span class="number">20</span>}).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// user -&gt; User{Name: "non_existing", Age: 20} if not found</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If a User named "Jinzhu" is found, update the struct with Assign attributes</span></span><br><span class="line">db.Where(User{Name: <span class="string">"Jinzhu"</span>}).Assign(User{Age: <span class="number">20</span>}).FirstOrInit(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM USERS WHERE name = 'Jinzhu' ORDER BY id LIMIT 1;</span></span><br><span class="line"><span class="comment">// user -&gt; User{ID: 111, Name: "Jinzhu", Age: 20} if found</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>FirstOrInit</code>, along with <code>Attrs</code> and <code>Assign</code>, provides a powerful and flexible way to ensure a record exists and is initialized or updated with specific attributes in a single step.</p>
<h2 id="FirstOrCreate" class="article-heading"><a href="#FirstOrCreate" class="headerlink" title="FirstOrCreate"></a>FirstOrCreate<a class="article-anchor" href="#FirstOrCreate" aria-hidden="true"></a></h2><p><code>FirstOrCreate</code> in GORM is used to fetch the first record that matches given conditions or create a new one if no matching record is found. This method is effective with both struct and map conditions. The <code>RowsAffected</code> property is useful to determine the number of records created or updated.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new record if not found</span></span><br><span class="line">result := db.FirstOrCreate(&amp;user, User{Name: <span class="string">"non_existing"</span>})</span><br><span class="line"><span class="comment">// SQL: INSERT INTO "users" (name) VALUES ("non_existing");</span></span><br><span class="line"><span class="comment">// user -&gt; User{ID: 112, Name: "non_existing"}</span></span><br><span class="line"><span class="comment">// result.RowsAffected // =&gt; 1 (record created)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If the user is found, no new record is created</span></span><br><span class="line">result = db.Where(User{Name: <span class="string">"jinzhu"</span>}).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// user -&gt; User{ID: 111, Name: "jinzhu", Age: 18}</span></span><br><span class="line"><span class="comment">// result.RowsAffected // =&gt; 0 (no record created)</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Using-Attrs-with-FirstOrCreate" class="article-heading"><a href="#Using-Attrs-with-FirstOrCreate" class="headerlink" title="Using Attrs with FirstOrCreate"></a>Using <code>Attrs</code> with FirstOrCreate<a class="article-anchor" href="#Using-Attrs-with-FirstOrCreate" aria-hidden="true"></a></h3><p><code>Attrs</code> can be used to specify additional attributes for the new record if it is not found. These attributes are used for creation but not in the initial search query.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new record with additional attributes if not found</span></span><br><span class="line">db.Where(User{Name: <span class="string">"non_existing"</span>}).Attrs(User{Age: <span class="number">20</span>}).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM users WHERE name = 'non_existing';</span></span><br><span class="line"><span class="comment">// SQL: INSERT INTO "users" (name, age) VALUES ("non_existing", 20);</span></span><br><span class="line"><span class="comment">// user -&gt; User{ID: 112, Name: "non_existing", Age: 20}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If the user is found, `Attrs` are ignored</span></span><br><span class="line">db.Where(User{Name: <span class="string">"jinzhu"</span>}).Attrs(User{Age: <span class="number">20</span>}).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM users WHERE name = 'jinzhu';</span></span><br><span class="line"><span class="comment">// user -&gt; User{ID: 111, Name: "jinzhu", Age: 18}</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Using-Assign-with-FirstOrCreate" class="article-heading"><a href="#Using-Assign-with-FirstOrCreate" class="headerlink" title="Using Assign with FirstOrCreate"></a>Using <code>Assign</code> with FirstOrCreate<a class="article-anchor" href="#Using-Assign-with-FirstOrCreate" aria-hidden="true"></a></h3><p>The <code>Assign</code> method sets attributes on the record regardless of whether it is found or not, and these attributes are saved back to the database.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize and save new record with `Assign` attributes if not found</span></span><br><span class="line">db.Where(User{Name: <span class="string">"non_existing"</span>}).Assign(User{Age: <span class="number">20</span>}).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM users WHERE name = 'non_existing';</span></span><br><span class="line"><span class="comment">// SQL: INSERT INTO "users" (name, age) VALUES ("non_existing", 20);</span></span><br><span class="line"><span class="comment">// user -&gt; User{ID: 112, Name: "non_existing", Age: 20}</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update found record with `Assign` attributes</span></span><br><span class="line">db.Where(User{Name: <span class="string">"jinzhu"</span>}).Assign(User{Age: <span class="number">20</span>}).FirstOrCreate(&amp;user)</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM users WHERE name = 'jinzhu';</span></span><br><span class="line"><span class="comment">// SQL: UPDATE users SET age=20 WHERE id = 111;</span></span><br><span class="line"><span class="comment">// user -&gt; User{ID: 111, Name: "Jinzhu", Age: 20}</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Оптимизатор-x2F-Индексы" class="article-heading"><a href="#Оптимизатор-x2F-Индексы" class="headerlink" title="Оптимизатор/Индексы"></a>Оптимизатор/Индексы<a class="article-anchor" href="#Оптимизатор-x2F-Индексы" aria-hidden="true"></a></h2><p>GORM includes support for optimizer and index hints, allowing you to influence the query optimizer’s execution plan. This can be particularly useful in optimizing query performance or when dealing with complex queries.</p>
<p>Optimizer hints are directives that suggest how a database’s query optimizer should execute a query. GORM facilitates the use of optimizer hints through the gorm.io/hints package.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"gorm.io/hints"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Using an optimizer hint to set a maximum execution time</span></span><br><span class="line">db.Clauses(hints.New(<span class="string">"MAX_EXECUTION_TIME(10000)"</span>)).Find(&amp;User{})</span><br><span class="line"><span class="comment">// SQL: SELECT * /*+ MAX_EXECUTION_TIME(10000) */ FROM `users`</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Index-Hints" class="article-heading"><a href="#Index-Hints" class="headerlink" title="Index Hints"></a>Index Hints<a class="article-anchor" href="#Index-Hints" aria-hidden="true"></a></h3><p>Index hints provide guidance to the database about which indexes to use. They can be beneficial if the query planner is not selecting the most efficient indexes for a query.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"gorm.io/hints"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Suggesting the use of a specific index</span></span><br><span class="line">db.Clauses(hints.UseIndex(<span class="string">"idx_user_name"</span>)).Find(&amp;User{})</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `users` USE INDEX (`idx_user_name`)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Forcing the use of certain indexes for a JOIN operation</span></span><br><span class="line">db.Clauses(hints.ForceIndex(<span class="string">"idx_user_name"</span>, <span class="string">"idx_user_id"</span>).ForJoin()).Find(&amp;User{})</span><br><span class="line"><span class="comment">// SQL: SELECT * FROM `users` FORCE INDEX FOR JOIN (`idx_user_name`,`idx_user_id`)</span></span><br></pre></td></tr></tbody></table></figure>

<p>These hints can significantly impact query performance and behavior, especially in large databases or complex data models. For more detailed information and additional examples, refer to <a href="hints.html">Optimizer Hints/Index/Comment</a> in the GORM documentation.</p>
<h2 id="Итерация" class="article-heading"><a href="#Итерация" class="headerlink" title="Итерация"></a>Итерация<a class="article-anchor" href="#Итерация" aria-hidden="true"></a></h2><p>GORM supports the iteration over query results using the <code>Rows</code> method. This feature is particularly useful when you need to process large datasets or perform operations on each record individually.</p>
<p>You can iterate through rows returned by a query, scanning each row into a struct. This method provides granular control over how each record is handled.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">rows, err := db.Model(&amp;User{}).Where(<span class="string">"name = ?"</span>, <span class="string">"jinzhu"</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() {</span><br><span class="line">  <span class="keyword">var</span> user User</span><br><span class="line">  <span class="comment">// ScanRows scans a row into a struct</span></span><br><span class="line">  db.ScanRows(rows, &amp;user)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform operations on each user</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>This approach is ideal for complex data processing that cannot be easily achieved with standard query methods.</p>
<h2 id="FindInBatches" class="article-heading"><a href="#FindInBatches" class="headerlink" title="FindInBatches"></a>FindInBatches<a class="article-anchor" href="#FindInBatches" aria-hidden="true"></a></h2><p><code>FindInBatches</code> allows querying and processing records in batches. This is especially useful for handling large datasets efficiently, reducing memory usage and improving performance.</p>
<p>With <code>FindInBatches</code>, GORM processes records in specified batch sizes. Inside the batch processing function, you can apply operations to each batch of records.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Processing records in batches of 100</span></span><br><span class="line">result := db.Where(<span class="string">"processed = ?"</span>, <span class="literal">false</span>).FindInBatches(&amp;results, <span class="number">100</span>, <span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB, batch <span class="type">int</span>)</span></span> <span class="type">error</span> {</span><br><span class="line">  <span class="keyword">for</span> _, result := <span class="keyword">range</span> results {</span><br><span class="line">    <span class="comment">// Operations on each record in the batch</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save changes to the records in the current batch</span></span><br><span class="line">  tx.Save(&amp;results)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tx.RowsAffected provides the count of records in the current batch</span></span><br><span class="line">  <span class="comment">// The variable 'batch' indicates the current batch number</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returning an error will stop further batch processing</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="comment">// result.Error contains any errors encountered during batch processing</span></span><br><span class="line"><span class="comment">// result.RowsAffected provides the count of all processed records across batches</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>FindInBatches</code> is an effective tool for processing large volumes of data in manageable chunks, optimizing resource usage and performance.</p>
<h2 id="Хуки-запросов" class="article-heading"><a href="#Хуки-запросов" class="headerlink" title="Хуки запросов"></a>Хуки запросов<a class="article-anchor" href="#Хуки-запросов" aria-hidden="true"></a></h2><p>GORM offers the ability to use hooks, such as <code>AfterFind</code>, which are triggered during the lifecycle of a query. These hooks allow for custom logic to be executed at specific points, such as after a record has been retrieved from the databas.</p>
<p>This hook is useful for post-query data manipulation or default value settings. For more detailed information and additional hook types, refer to <a href="hooks.html">Hooks</a> in the GORM documentation.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> AfterFind(tx *gorm.DB) (err <span class="type">error</span>) {</span><br><span class="line">  <span class="comment">// Custom logic after finding a user</span></span><br><span class="line">  <span class="keyword">if</span> u.Role == <span class="string">""</span> {</span><br><span class="line">    u.Role = <span class="string">"user"</span> <span class="comment">// Set default role if not specified</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage of AfterFind hook happens automatically when a User is queried</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="Pluck" class="article-heading"><a href="#Pluck" class="headerlink" title="Pluck"></a><span id="pluck">Pluck</span><a class="article-anchor" href="#Pluck" aria-hidden="true"></a></h2><p>The <code>Pluck</code> method in GORM is used to query a single column from the database and scan the result into a slice. This method is ideal for when you need to retrieve specific fields from a model.</p>
<p>If you need to query more than one column, you can use <code>Select</code> with <a href="query.html">Scan</a> or <a href="query.html">Find</a> instead.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Retrieving ages of all users</span></span><br><span class="line"><span class="keyword">var</span> ages []<span class="type">int64</span></span><br><span class="line">db.Model(&amp;User{}).Pluck(<span class="string">"age"</span>, &amp;ages)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieving names of all users</span></span><br><span class="line"><span class="keyword">var</span> names []<span class="type">string</span></span><br><span class="line">db.Model(&amp;User{}).Pluck(<span class="string">"name"</span>, &amp;names)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieving names from a different table</span></span><br><span class="line">db.Table(<span class="string">"deleted_users"</span>).Pluck(<span class="string">"name"</span>, &amp;names)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using Distinct with Pluck</span></span><br><span class="line">db.Model(&amp;User{}).Distinct().Pluck(<span class="string">"Name"</span>, &amp;names)</span><br><span class="line"><span class="comment">// SQL: SELECT DISTINCT `name` FROM `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Querying multiple columns</span></span><br><span class="line">db.Select(<span class="string">"name"</span>, <span class="string">"age"</span>).Scan(&amp;users)</span><br><span class="line">db.Select(<span class="string">"name"</span>, <span class="string">"age"</span>).Find(&amp;users)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Scopes" class="article-heading"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes<a class="article-anchor" href="#Scopes" aria-hidden="true"></a></h2><p><code>Scopes</code> in GORM are a powerful feature that allows you to define commonly-used query conditions as reusable methods. These scopes can be easily referenced in your queries, making your code more modular and readable.</p>
<h3 id="Defining-Scopes" class="article-heading"><a href="#Defining-Scopes" class="headerlink" title="Defining Scopes"></a>Defining Scopes<a class="article-anchor" href="#Defining-Scopes" aria-hidden="true"></a></h3><p><code>Scopes</code> are defined as functions that modify and return a <code>gorm.DB</code> instance. You can define a variety of conditions as scopes based on your application’s requirements.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Scope for filtering records where amount is greater than 1000</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AmountGreaterThan1000</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB {</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">"amount &gt; ?"</span>, <span class="number">1000</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scope for orders paid with a credit card</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PaidWithCreditCard</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB {</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">"pay_mode_sign = ?"</span>, <span class="string">"C"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scope for orders paid with cash on delivery (COD)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PaidWithCod</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB {</span><br><span class="line">  <span class="keyword">return</span> db.Where(<span class="string">"pay_mode_sign = ?"</span>, <span class="string">"COD"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scope for filtering orders by status</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderStatus</span><span class="params">(status []<span class="type">string</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB {</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB {</span><br><span class="line">    <span class="keyword">return</span> db.Where(<span class="string">"status IN (?)"</span>, status)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Applying-Scopes-in-Queries" class="article-heading"><a href="#Applying-Scopes-in-Queries" class="headerlink" title="Applying Scopes in Queries"></a>Applying Scopes in Queries<a class="article-anchor" href="#Applying-Scopes-in-Queries" aria-hidden="true"></a></h3><p>You can apply one or more scopes to a query by using the <code>Scopes</code> method. This allows you to chain multiple conditions dynamically.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Applying scopes to find all credit card orders with an amount greater than 1000</span></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(&amp;orders)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Applying scopes to find all COD orders with an amount greater than 1000</span></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(&amp;orders)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Applying scopes to find all orders with specific statuses and an amount greater than 1000</span></span><br><span class="line">db.Scopes(AmountGreaterThan1000, OrderStatus([]<span class="type">string</span>{<span class="string">"paid"</span>, <span class="string">"shipped"</span>})).Find(&amp;orders)</span><br></pre></td></tr></tbody></table></figure>

<p><code>Scopes</code> are a clean and efficient way to encapsulate common query logic, enhancing the maintainability and readability of your code. For more detailed examples and usage, refer to <a href="scopes.html">Scopes</a> in the GORM documentation.</p>
<h2 id="Count" class="article-heading"><a href="#Count" class="headerlink" title="Count"></a><span id="count">Count</span><a class="article-anchor" href="#Count" aria-hidden="true"></a></h2><p>The <code>Count</code> method in GORM is used to retrieve the number of records that match a given query. It’s a useful feature for understanding the size of a dataset, particularly in scenarios involving conditional queries or data analysis.</p>
<h3 id="Getting-the-Count-of-Matched-Records" class="article-heading"><a href="#Getting-the-Count-of-Matched-Records" class="headerlink" title="Getting the Count of Matched Records"></a>Getting the Count of Matched Records<a class="article-anchor" href="#Getting-the-Count-of-Matched-Records" aria-hidden="true"></a></h3><p>You can use <code>Count</code> to determine the number of records that meet specific criteria in your queries.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Counting users with specific names</span></span><br><span class="line">db.Model(&amp;User{}).Where(<span class="string">"name = ?"</span>, <span class="string">"jinzhu"</span>).Or(<span class="string">"name = ?"</span>, <span class="string">"jinzhu 2"</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SQL: SELECT count(1) FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Counting users with a single name condition</span></span><br><span class="line">db.Model(&amp;User{}).Where(<span class="string">"name = ?"</span>, <span class="string">"jinzhu"</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SQL: SELECT count(1) FROM users WHERE name = 'jinzhu'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Counting records in a different table</span></span><br><span class="line">db.Table(<span class="string">"deleted_users"</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SQL: SELECT count(1) FROM deleted_users</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Count-with-Distinct-and-Group" class="article-heading"><a href="#Count-with-Distinct-and-Group" class="headerlink" title="Count with Distinct and Group"></a>Count with Distinct and Group<a class="article-anchor" href="#Count-with-Distinct-and-Group" aria-hidden="true"></a></h3><p>GORM also allows counting distinct values and grouping results.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Counting distinct names</span></span><br><span class="line">db.Model(&amp;User{}).Distinct(<span class="string">"name"</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SQL: SELECT COUNT(DISTINCT(`name`)) FROM `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Counting distinct values with a custom select</span></span><br><span class="line">db.Table(<span class="string">"deleted_users"</span>).Select(<span class="string">"count(distinct(name))"</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// SQL: SELECT count(distinct(name)) FROM deleted_users</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Counting grouped records</span></span><br><span class="line">users := []User{</span><br><span class="line">  {Name: <span class="string">"name1"</span>},</span><br><span class="line">  {Name: <span class="string">"name2"</span>},</span><br><span class="line">  {Name: <span class="string">"name3"</span>},</span><br><span class="line">  {Name: <span class="string">"name3"</span>},</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User{}).Group(<span class="string">"name"</span>).Count(&amp;count)</span><br><span class="line"><span class="comment">// Count after grouping by name</span></span><br><span class="line"><span class="comment">// count =&gt; 3</span></span><br></pre></td></tr></tbody></table></figure>
</body></html>
              </div>

              
              <div>
                <a href="v2_release_note.html" target="_blank">
                  <img alt="GitHub tag (latest SemVer)" src="https://img.shields.io/github/v/tag/go-gorm/gorm?label=Latest GORM Release&color=red&&style=for-the-badge&logo=go&logoColor=red">
                </a>
              </div>
              

              <footer class="article-footer">
                <time class="article-footer-updated" datetime="2024-06-12T08:58:10.034Z" itemprop="dateModified">Последнее обновление: 2024-06-12</time>
<a href="query.html" class="article-footer-prev" title="Запрос"><i class="fa fa-chevron-left"></i><span>Пред.</span></a><a href="update.html" class="article-footer-next" title="Обновление"><span>След.</span><i class="fa fa-chevron-right"></i></a>
              </footer>

              <div class="post_sponsors">
                <div class="sponsors-wrapper-pc open-collective-sponsors">
  <div class="inner">
    <div class="sponsors">
      <h1>Platinum Sponsors <i class="far fa-kiss-wink-heart"></i></h1>
      <!-- <div class="sponsor_item"> -->
      <!--   <a href="https://chainlinklabs.com" target="_blank" rel="sponsored noopener"> -->
      <!--     <img src="/sponsors-imgs/chainlink.png" alt="chainlink"> -->
      <!--   </a> -->
      <!-- </div> -->
      <div class="sponsor_item" title="Help to deliver a better GORM!">
        <a class="become-sponsor" href="/contribute.html#Donations">Become a Sponsor!</a>
      </div>
    </div>

    <div class="sponsors">
      <h1>Gold Sponsors <i class="far fa-kiss-wink-heart"></i></h1>
      <!-- <div class="sponsor_item"> -->
      <!--   <a href="https://hubuc.com" target="_blank" rel="sponsored noopener" title="hubuc"> -->
      <!--     <img src="/sponsors-imgs/hubuc.svg" alt="hubuc"> -->
      <!--   </a> -->
      <!-- </div> -->
      <div class="sponsor_item sponsor_item_link">
        <a href="https://www.encore.dev/?utm_source=github&utm_medium=github-gorm-sponsor-logo&utm_campaign=gorm-20231215" target="_blank" rel="sponsored noopener" title="Encore">
          <img src="/sponsors-imgs/encore.png" alt="Encore">
        </a>
      </div>
      <div class="sponsor_item sponsor_item_link">
        <a href="https://incident.io" target="_blank" rel="sponsored noopener" title="Incident.io">
          <img src="/sponsors-imgs/incident-io.svg" alt="Incident.io">
        </a>
      </div>

      <div class="sponsor_item" title="Help to deliver a better GORM!">
        <a class="become-sponsor" href="/contribute.html#Donations">Become a Sponsor!</a>
      </div>

      
    </div>
  </div>
</div>

<div class="sponsors-wrapper-mobile open-collective-sponsors">
  <div class="inner">
    <div class="sponsors">
      <h1>Platinum Sponsors</h1>
      <!-- <div class="sponsor_item"> -->
      <!--   <a href="https://chainlinklabs.com" target="_blank" rel="sponsored noopener"> -->
      <!--     <img src="/sponsors-imgs/chainlink.png" alt="chainlink"> -->
      <!--   </a> -->
      <!-- </div> -->
      <div class="sponsor_item" title="Help to deliver a better GORM!">
        <a class="become-sponsor" href="/contribute.html#Donations">Become a Sponsor!</a>
      </div>
    </div>

    <div class="sponsors">
      <h1>Gold Sponsors</h1>
      <!-- <div class="sponsor_item"> -->
      <!--   <a href="https://chainlinklabs.com" target="_blank" rel="sponsored noopener" title="hubuc"> -->
      <!--     <img src="/sponsors-imgs/hubuc.svg" alt="hubuc"> -->
      <!--   </a> -->
      <!-- </div> -->
      <!-- <div class="sponsor_item"> -->
      <!--   <a href="https://www.bytebase.com/?utm_source=github&utm_medium=github-gorm-sponsor-logo&utm_campaign=gorm-20220715" target="_blank" rel="sponsored noopener" title="bytebase"> -->
      <!--     <img src="/sponsors-imgs/bytebase.png" alt="bytebase"> -->
      <!--   </a> -->
      <!-- </div> -->
      <div class="sponsor_item">
        <a href="https://www.encore.dev/?utm_source=github&utm_medium=github-gorm-sponsor-logo&utm_campaign=gorm-20231215" target="_blank" rel="sponsored noopener" title="Encore">
          <img src="/sponsors-imgs/encore.png" alt="Encore">
        </a>
      </div>
      <div class="sponsor_item">
        <a href="https://incident.io" target="_blank" rel="sponsored noopener" title="Incident.io">
          <img src="/sponsors-imgs/incident-io.svg" alt="Incident.io">
        </a>
      </div>

      <div class="sponsor_item" title="Help to deliver a better GORM!">
        <a class="become-sponsor" href="/contribute.html#Donations">Become a Sponsor!</a>
      </div>
    </div>
  </div>
</div>

              </div>

              <!--  -->
<!-- <section id="comments"> -->
<!-- <div id="disqus_thread"></div> -->
<!-- </sction> -->

<!-- <script> -->
<!-- var disqus_config = function () { -->
<!-- this.page.url = 'https://gorm.io/ru_RU/docs/advanced_query.html'; -->
<!-- this.page.identifier = 'https://gorm.io/ru_RU/docs/advanced_query.html'; -->
<!-- this.language = 'ru'; -->
<!-- }; -->

<!-- (function() { // DON'T EDIT BELOW THIS LINE -->
<!-- var d = document, s = d.createElement('script'); -->
<!-- s.src = 'https://gormv2.disqus.com/embed.js'; -->
<!-- s.setAttribute('data-timestamp', +new Date()); -->
<!-- (d.head || d.body).appendChild(s); -->
<!-- })(); -->
<!-- </script> -->
<!--  -->

            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <div id="sidebar-ad-wrapper" class="tagmanager_ad"></div>
              <strong class="sidebar-title">Содержимое</strong>
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%D0%A3%D0%BC%D0%BD%D1%8B%D0%B9-%D0%B2%D1%8B%D0%B1%D0%BE%D1%80-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9"><span class="toc-text">Умный выбор полей</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Locking"><span class="toc-text">Locking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%D0%9F%D0%BE%D0%B4%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81"><span class="toc-text">Подзапрос</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%D0%98%D0%B7-SubQuery-%D0%BF%D0%BE%D0%B4-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0"><span class="toc-text">Из SubQuery (под запроса)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%D0%93%D1%80%D1%83%D0%BF%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B9"><span class="toc-text">Группировка условий</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IN-%D1%81-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8%D0%BC%D0%B8-%D1%81%D1%82%D0%BE%D0%BB%D0%B1%D1%86%D0%B0%D0%BC%D0%B8"><span class="toc-text">IN с несколькими столбцами</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%D0%98%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B0%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B"><span class="toc-text">Именованные аргументы</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Find-%D1%81-%D0%BA%D0%B0%D1%80%D1%82%D0%B0%D0%BC%D0%B8"><span class="toc-text">Find с картами</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FirstOrInit"><span class="toc-text">FirstOrInit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Attrs-for-Initialization"><span class="toc-text">Using Attrs for Initialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Assign-for-Attributes"><span class="toc-text">Using Assign for Attributes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FirstOrCreate"><span class="toc-text">FirstOrCreate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Attrs-with-FirstOrCreate"><span class="toc-text">Using Attrs with FirstOrCreate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Using-Assign-with-FirstOrCreate"><span class="toc-text">Using Assign with FirstOrCreate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%D0%9E%D0%BF%D1%82%D0%B8%D0%BC%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80-x2F-%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%8B"><span class="toc-text">Оптимизатор&#x2F;Индексы</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Index-Hints"><span class="toc-text">Index Hints</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F"><span class="toc-text">Итерация</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FindInBatches"><span class="toc-text">FindInBatches</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%D0%A5%D1%83%D0%BA%D0%B8-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2"><span class="toc-text">Хуки запросов</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pluck"><span class="toc-text">Pluck</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scopes"><span class="toc-text">Scopes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-Scopes"><span class="toc-text">Defining Scopes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Applying-Scopes-in-Queries"><span class="toc-text">Applying Scopes in Queries</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Count"><span class="toc-text">Count</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Getting-the-Count-of-Matched-Records"><span class="toc-text">Getting the Count of Matched Records</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Count-with-Distinct-and-Group"><span class="toc-text">Count with Distinct and Group</span></a></li></ol></li></ol>

              
                <a href="https://translate.gorm.io/project/go-gorm/ru" target="_blank" id="article-improve">
                  Улучшить эту страницу
                </a>
              
              <a href="#" id="article-toc-top">Вернуться к началу</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner">
    <strong class="sidebar-title">Начало работы</strong><a href="index.html" class="sidebar-link">Обзор</a><a href="models.html" class="sidebar-link">Объявление моделей</a><a href="connecting_to_the_database.html" class="sidebar-link">Подключение к базе данных</a><strong class="sidebar-title">CRUD интерфейс</strong><a href="create.html" class="sidebar-link">Создать</a><a href="query.html" class="sidebar-link">Запрос</a><a href="advanced_query.html" class="sidebar-link current">Расширенный запрос</a><a href="update.html" class="sidebar-link">Обновление</a><a href="delete.html" class="sidebar-link">Удалить</a><a href="sql_builder.html" class="sidebar-link">Raw SQL и конструктор SQL</a><strong class="sidebar-title">Связи</strong><a href="belongs_to.html" class="sidebar-link">Belongs To</a><a href="has_one.html" class="sidebar-link">Has One</a><a href="has_many.html" class="sidebar-link">Has Many</a><a href="many_to_many.html" class="sidebar-link">Many To Many</a><a href="polymorphism.html" class="sidebar-link">Polymorphism</a><a href="associations.html" class="sidebar-link">Режим связи</a><a href="preload.html" class="sidebar-link">Предзагрузка (Нетерпеливая загрузка)</a><strong class="sidebar-title">Обучение</strong><a href="context.html" class="sidebar-link">Контекст</a><a href="error_handling.html" class="sidebar-link">Обработка ошибок</a><a href="method_chaining.html" class="sidebar-link">Цепочки методов</a><a href="session.html" class="sidebar-link">Сессия</a><a href="hooks.html" class="sidebar-link">Хуки</a><a href="transactions.html" class="sidebar-link">Транзакции</a><a href="migration.html" class="sidebar-link">Миграция</a><a href="logger.html" class="sidebar-link">Logger</a><a href="generic_interface.html" class="sidebar-link">Универсальный интерфейс базы данных</a><a href="performance.html" class="sidebar-link">Производительность</a><a href="data_types.html" class="sidebar-link">Настройка типов данных</a><a href="scopes.html" class="sidebar-link">Области</a><a href="conventions.html" class="sidebar-link">Преобразования</a><a href="settings.html" class="sidebar-link">Настройки</a><strong class="sidebar-title">Дополнительные возможности</strong><a href="dbresolver.html" class="sidebar-link">Резолвер базы данных</a><a href="sharding.html" class="sidebar-link">Шардирование</a><a href="serializer.html" class="sidebar-link">Сериализатор</a><a href="prometheus.html" class="sidebar-link">Prometheus</a><a href="hints.html" class="sidebar-link">Подсказки</a><a href="indexes.html" class="sidebar-link">Индексы</a><a href="constraints.html" class="sidebar-link">Ограничения</a><a href="composite_primary_key.html" class="sidebar-link">Композитный первичный ключ</a><a href="security.html" class="sidebar-link">Безопасность</a><a href="gorm_config.html" class="sidebar-link">Настройки GORM</a><a href="write_plugins.html" class="sidebar-link">Написание плагинов</a><a href="write_driver.html" class="sidebar-link">Написание драйверов</a><a href="changelog.html" class="sidebar-link">История изменений</a><a href="/community.html" class="sidebar-link">Сообщество</a><a href="/contribute.html" class="sidebar-link">Внести вклад</a><a href="/contribute.html#Translate-this-site" class="sidebar-link">Перевести текущий сайт</a>
  </div>
</aside>

    </div>
  </div>
</div>

    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2013~2024 <a href="https://github.com/jinzhu" target="_blank">Jinzhu</a><br>
      Documentation licensed under <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>.<br>
      <div id="gorm.cn" style="display:none">
      感谢 <a href="https://github.com/unknwon" target="_blank">无闻</a> 对域名 <a href="https://gorm.cn" target="_blank">gorm.cn</a> 的捐赠<br>
      <a href="http://beian.miit.gov.cn/" target="_blank" data-spm-anchor-id="a3c00.7621333.7y9jhqsfz.112">浙ICP备2020033190号-1</a><br>
      </div>

      <script>
        if (window.location.hostname.includes("gorm.cn")) {
          document.getElementById("gorm.cn").style.display = 'block';
        }
      </script>
    </div>
    <div id="footer-links">
      <a href="https://twitter.com/zhangjinzhu" class="footer-link" target="_blank"><i class="fab fa-twitter"></i></a>
      <a href="https://github.com/go-gorm/gorm" class="footer-link" target="_blank"><i class="fab fa-github-alt"></i></a>
    </div>
  </div>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <li class="mobile-nav-item">
        <a href="/" class="mobile-nav-link" rel="external" target="_blank"><i class="fa fa-home"></i>Главная</a>
      </li>
      <a href="/ru_RU/docs/" class="mobile-nav-link"><i class="fa fa-book"></i>Документация</a><a href="/ru_RU/gen/" class="mobile-nav-link"><i class="fa fa-tools"></i>Gen</a><a href="/ru_RU/community.html" class="mobile-nav-link"><i class="fab fa-slack"></i>Сообщество</a><a href="https://pkg.go.dev/gorm.io/gorm" class="mobile-nav-link" target="_blank"><i class="fa fa-cogs"></i>API</a><a href="/ru_RU/contribute.html" class="mobile-nav-link"><i class="fa fa-rocket"></i>Внести вклад</a>
    </ul>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>Русский</span></span>
    <select id="mobile-lang-select" data-canonical="docs/advanced_query.html">
      
        <option value="en">English</option>
      
        <option value="zh_CN">简体中文</option>
      
        <option value="de_DE">Deutsch</option>
      
        <option value="id_ID">bahasa Indonesia</option>
      
        <option value="ja_JP">日本語</option>
      
        <option value="ru_RU" selected>Русский</option>
      
        <option value="ko_KR">한국어</option>
      
        <option value="hi_IN">हिन्दी</option>
      
        <option value="fr_FR">French</option>
      
        <option value="it_IT">Italiano</option>
      
        <option value="es_ES">Español</option>
      
    </select>
  </div>
</nav>

  <!-- Scripts -->
<!-- build:js build/js/main.js -->

<script src="/js/lang_select.js"></script>


<script src="/js/toc.js"></script>


<script src="/js/mobile_nav.js"></script>


<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>

<script src="/js/code_expander.js"></script>

<!-- endbuild -->

<!-- Algolia -->



<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WSNPD75"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->


</body>
</html>
